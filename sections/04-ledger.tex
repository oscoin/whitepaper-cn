\section{\oscoin{}账本}
\label{s:ledger}

\def\posnat{\mathbb{N}_{\geq 1}}

\oscoin{}网络包含一系列节点，或称副本，用来执行去中心化协议。这些节点共同组成复制状态机，元素包括一个状态集合$\state_0, \ldots, \state_n$，一个转换函数$\Xi$，一系列的输入$B_0, \ldots, B_n$，或称“链”，其中$B_0$为创世区块，以及一系列输出。

\oscoin{}账本，即$\ledger$，是经过全网达成共识的有序交易集。更新账本的过程就是在网络中提交交易确认的过程。所有被确认的交易共同组成状态$\state$，即现阶段全局交易状态。

本章将描述如何在账本上更新交易，以及交易如何影响全局状态$\state$。

\subsection{供应}
\label{s:supply}

\oscoin{}的供应量遵从固定的供应曲线，且每个周期都有$B_r > 0$的增量。这确保了\oscoin{}持续流入财政系统，奖励网络中有价值的工作。

\subsection{账户}
\label{s:accounts}

账户持有者用签名解锁账户中的\oscoin{}，账户中保存着可以用来收发\oscoin{}的地址。这是一种与比特币的\emph{utxo}不同的类以太坊账户的设计。

通过转账即可创建新账户，账本余额为0时可以销户。所有账户的集合为$\accounts$。

账户账本余额$A_b$被记录在全局状态$\state$中，账户地址$A_a$可查询该账户余额。记为，$\state(A_a) \to A_b$。

每个账户还关联一个智能合约，记为$\field{A}{contract}$，可确认和处理账户中流入和流出的\oscoin{}。

\subsection{转账\oscoin{}}
\label{s:transfering}

集合$\accounts$中的每一个账户都有一个\oscoin{}余额：
\[
    \bal(a) \in \posnat \mid a \in \accounts.
\]
账户的转账操作表示如下
\[
    \tx{transfer}{x,y,n} \mid x,y \in \accounts, n \in \posnat
\]
其中$x$是提取\oscoin{}的账户，y是\oscoin{}存入的地址，$n$是交易量。只要$\bal(x) \geq n$（转出账户余额大于转出数量）则交易合法，$x$ 与 $y$各自关联的智能合约将授权执行这次转账交易。

\subsection{项目}
\label{s:projects}

% TODO: Project-id file in project source code

项目$P$可表示为一列元组数据：
\[
    P = \tuple{P_a, P_h, P_s}
\]
其中$P_{a}$ 指的是项目的地址，是独特身份标识。$P_h$为项目当前哈希值，$P_s$以标准典式记录项目URL。

项目地址（字母数字字符串）是每个项目在账本交易中的独立身份标识。每个项目都拥有一个与地址相关联的特殊账户，叫做项目资金。项目哈希是每个项目被纳入账本时的源代码摘要。记录项目URL是出于便利性考虑，为了方便检索代码源。注意，通过$P_s$攫取的源代码的哈希值必须等于$P_h$，否则项目将被视为非法。

\subsubsection{注册和维护} 项目须先进行注册交易才能加入网络：
\[
    \tx{register}{P_a, P_s}
\]
被秘钥$k_1$签名过的注册交易才可在之后被更新到账本中。只有当地址$P_a$没被启用，且$P_s$是有效URL时，转账才有效。

注册成功后，账户中一小部分\oscoin{}经$k_1$签名后锁定。一定程度上防止大量弃用项目的出现扰乱账本。以上程序执行后，项目元组数据 $P =
\tuple{P_a, P_h, P_s}$将被部分重置：$P_h = \varnothing$。

项目$P$现有的秘钥串$P_K$ 为 $\{k_1\}$，我们将这些秘钥串称为项目的维护者。秘钥才是项目的实际控制者，享有项目管理权。可以进一步向$P_K$中添加新秘钥：
\[
    \tx{addkey}{P_a, k}
\]
添加前，$k$是不存在于原秘钥串$P_K$ 中的合法秘钥。秘钥也可以被移除：
\[
    \tx{removekey}{P_a, k}
\]
移除前，$k$存在于$P_K$中。当项目无人运维时，可以从账本中注销：
\[
    \tx{unregister}{P_a}.
\]

项目注销时，之前质押的\oscoin{}经$k_1$签名退还回账户中。以上所有步骤都须经$P_K$中的合法秘钥签名实现。
在账本中注册的项目可通过注册条目$\registry$中的项目地址检索出来，记为：$\registry(P_a) \to P$。

\subsubsection{检查点} \label{s:checkpointing} 处于开发进程中的活跃项目的源代码会有经常性的变动。这意味着项目哈希$P_h$需要时时进行同步，才能反映当前的项目状态。哈希更新和通过如下
\[
    \tx{checkpoint}{P_a, P_{h'}, P_{s'}, C^*, D^*}
\]
交易实现，其中$P_{h'}$为项目新哈希。$P_{s'}$可进行源代码检索的URL，$C^*$是代码贡献的哈希链表，$D^*$是依赖关系更新的清单。

代码贡献是元组数据表示为：
\[
   \tuple{\field{C}{prev}, \field{C}{commit}, \field{C}{author}, \field{C}{signoff}}
\]
其中：
\begin{itemize}
\item $\field{C}{prev}$是过去贡献的哈希，如果项目之前无任何提交代码，则用⌀来表示。$C^*$的首个元素，必须关联到项目前一次检查点的最后一次贡献，这样就不会割裂对贡献的记录。
\item $\field{C}{commit}$ 是对应的代码提交的哈希
\item $\field{C}{author}$是代码提交者（贡献者）
\item $\field{C}{sig}$ 是代码提交人的签名
\item $\field{C}{signoff}$是验收秘钥，属于秘钥集合$\in P_K$
\end{itemize}
每个贡献都必须由验收秘钥进行签名。签名过程表明此次贡献已经由维护者进行复核与确认。检查点本身也必须由$P_K$中的一把秘钥进行签名。

因为检查点记录了所有的源代码的变动，所以我们可以用一张哈希互联的清单来重现整个项目。当我们对项目的代码库进行交叉检验时，代码的作者以及将代码贡献签署生效的维护者都会体现在历史记录中。这样的可审计且不可篡改的历史记录为\osrank{}提供了基础信息保障。注意这里只有贡献的元数据才会被存储上链。

\label{s:dependencies}

理论上，如果项目$P'$在$P$的输入（Input）中，即，在$P$在源代码中引用或部分引用了$P'$或$P'$是一个构造/测试依赖成分，则我们称项目P依赖于项目$P'$。例如，如果一个项目使用了纯粹功性能的包管理工具\emph{Nix} \cite{nix}，那在\oscoin{}中声明的依赖关系应该与Nix中的依赖关系一一对应。

依赖关系更新列表$D^*$是一个存放依赖关系更新的列表。依赖关系更新有
\[
    \depend(P'_a, n) \quad \text{or} \quad \undepend(P'_a, n)
\]
两种，都是指项目$P'$的第$n$个检查点（第一个检查点记为n=$0$）。$\depend$更新增加一个新的依赖关系，而$\undepend$更新移除一个依赖关系。更新将按$\depend$的顺序执行，并且只有当项目没有该依赖关系时添加行为才有效，而$\undepend$支队现存的依赖关系有效。当更新列表有重复时，检查点将无效。

作为项目维护者，增加一项依赖关系标志着项目实质的一连串改变：
\begin{itemize}
\item $P$依赖于特定版本的 $P'$真是存在并已被确认；
\item $P'$适宜作为$P$的一个依赖关系，例如，如果P有非常高的安全要求，$P'$也能完全满足。
\end{itemize}
\noindent 因为对一个项目的贡献承载着额外的权重，很有可能增加项目的\osrank{}，因此维护者有动力对项目规律地添加检查点。与此类似，增加依赖关系可能增加网络内的连通性，从而反过来间接地增加项目的\osrank{}。

\subsection{智能合约}

最后，账本允许智能合约来对交易进行一定程度的调解。我们将用接下来的篇幅讨论智能合约自动化执行资金分配并进行准入管理的操作。